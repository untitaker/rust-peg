// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]

  use translate::*;
  use std::num::from_str_radix;
  use std::char;

enum ParseResult<T> { Matched(uint, T), Failed, }
struct ParseState {
    max_err_pos: uint,
    expected: Vec<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0, expected: Vec::new(),}
    }
    fn mark_failure(&mut self, pos: uint, expected: &'static str) ->
     ParseResult<()> {
        if pos < self.max_err_pos { return Failed; }
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        self.expected.push(expected);
        Failed
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: uint, m: &'static str)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           input.as_bytes().slice(pos, pos + l) == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn any_char(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        Matched(input.char_range_at(pos).next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: uint) -> uint {
    let mut remaining = pos as int;
    let mut lineno: uint = 1;
    for line in input.lines() {
        remaining -= (line.len() as int) + 1;
        if remaining <= 0 { return lineno; }
        lineno += 1;
    }
    return lineno;
}
fn parse_grammar(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Grammar> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match parse_action(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, header) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_rust_use(input,
                                                                   state,
                                                                   pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, imports) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let mut repeat_pos =
                                                            pos;
                                                        let mut repeat_value =
                                                            vec!();
                                                        loop  {
                                                            let pos =
                                                                repeat_pos;
                                                            let step_res =
                                                                parse_rule(input,
                                                                           state,
                                                                           pos);
                                                            match step_res {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    repeat_pos
                                                                        =
                                                                        newpos;
                                                                    repeat_value.push(value);
                                                                }
                                                                Failed => {
                                                                    break ;
                                                                }
                                                            }
                                                        }
                                                        Matched(repeat_pos,
                                                                repeat_value)
                                                    };
                                                match seq_res {
                                                    Matched(pos, rules) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        Grammar{initializer:
                                                                                    header,
                                                                                imports:
                                                                                    imports,
                                                                                rules:
                                                                                    rules,}
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rule(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Rule> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_exportflag(input, state, pos);
            match seq_res {
                Matched(pos, exported) => {
                    {
                        let seq_res = parse_identifier(input, state, pos);
                        match seq_res {
                            Matched(pos, name) => {
                                {
                                    let seq_res =
                                        parse_returntype(input, state, pos);
                                    match seq_res {
                                        Matched(pos, returns) => {
                                            {
                                                let seq_res =
                                                    parse_equals(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_expression(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        expression)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            match parse_semicolon(input,
                                                                                                  state,
                                                                                                  pos)
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    Matched(newpos,
                                                                                            Some(value))
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    Matched(pos,
                                                                                            None)
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                Rule{name:
                                                                                                         name,
                                                                                                     expr:
                                                                                                         box() expression,
                                                                                                     ret_type:
                                                                                                         returns,
                                                                                                     exported:
                                                                                                         exported,}
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_exportflag(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<bool> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "#[export]");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed =>
                                slice_eq(input, state, pos, "#[pub]"),
                            }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse___(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { true })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos, { false })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_returntype(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_returns(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_rust_type(input, state,
                                                                pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Matched(pos,
                                                                {
                                                                    match_str.trim().to_string()
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, tp) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { tp })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let match_str = input.slice(start_pos, pos);
                    Matched(pos, { "()".to_string() })
                }
            }
        }
    }
}
fn parse_rust_use(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<RustUse> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "use");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_rust_path(input, state, pos);
                                    match seq_res {
                                        Matched(pos, p) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let choice_res =
                                                                        {
                                                                            let start_pos =
                                                                                pos;
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             "::");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse___(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            slice_eq(input,
                                                                                                                     state,
                                                                                                                     pos,
                                                                                                                     "*");
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        parse___(input,
                                                                                                                                 state,
                                                                                                                                 pos);
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                _)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let match_str =
                                                                                                                                    input.slice(start_pos,
                                                                                                                                                pos);
                                                                                                                                Matched(pos,
                                                                                                                                        {
                                                                                                                                            RustUseGlob(p.clone())
                                                                                                                                        })
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        };
                                                                    match choice_res
                                                                        {
                                                                        Matched(pos,
                                                                                value)
                                                                        =>
                                                                        Matched(pos,
                                                                                value),
                                                                        Failed
                                                                        => {
                                                                            let choice_res =
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "::");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse___(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    slice_eq(input,
                                                                                                                             state,
                                                                                                                             pos,
                                                                                                                             "{");
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Matched(pos,
                                                                                                                            _)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            let seq_res =
                                                                                                                                parse___(input,
                                                                                                                                         state,
                                                                                                                                         pos);
                                                                                                                            match seq_res
                                                                                                                                {
                                                                                                                                Matched(pos,
                                                                                                                                        _)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    {
                                                                                                                                        let seq_res =
                                                                                                                                            {
                                                                                                                                                let mut repeat_pos =
                                                                                                                                                    pos;
                                                                                                                                                let mut repeat_value =
                                                                                                                                                    vec!();
                                                                                                                                                loop 
                                                                                                                                                     {
                                                                                                                                                    let pos =
                                                                                                                                                        repeat_pos;
                                                                                                                                                    let pos =
                                                                                                                                                        if repeat_value.len()
                                                                                                                                                               >
                                                                                                                                                               0
                                                                                                                                                           {
                                                                                                                                                            let sep_res =
                                                                                                                                                                {
                                                                                                                                                                    let seq_res =
                                                                                                                                                                        slice_eq(input,
                                                                                                                                                                                 state,
                                                                                                                                                                                 pos,
                                                                                                                                                                                 ",");
                                                                                                                                                                    match seq_res
                                                                                                                                                                        {
                                                                                                                                                                        Matched(pos,
                                                                                                                                                                                _)
                                                                                                                                                                        =>
                                                                                                                                                                        {
                                                                                                                                                                            parse___(input,
                                                                                                                                                                                     state,
                                                                                                                                                                                     pos)
                                                                                                                                                                        }
                                                                                                                                                                        Failed
                                                                                                                                                                        =>
                                                                                                                                                                        Failed,
                                                                                                                                                                    }
                                                                                                                                                                };
                                                                                                                                                            match sep_res
                                                                                                                                                                {
                                                                                                                                                                Matched(newpos,
                                                                                                                                                                        _)
                                                                                                                                                                =>
                                                                                                                                                                {
                                                                                                                                                                    newpos
                                                                                                                                                                }
                                                                                                                                                                Failed
                                                                                                                                                                =>
                                                                                                                                                                break
                                                                                                                                                                    ,
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            pos
                                                                                                                                                        };
                                                                                                                                                    let step_res =
                                                                                                                                                        parse_identifier(input,
                                                                                                                                                                         state,
                                                                                                                                                                         pos);
                                                                                                                                                    match step_res
                                                                                                                                                        {
                                                                                                                                                        Matched(newpos,
                                                                                                                                                                value)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            repeat_pos
                                                                                                                                                                =
                                                                                                                                                                newpos;
                                                                                                                                                            repeat_value.push(value);
                                                                                                                                                        }
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            break
                                                                                                                                                                ;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                if repeat_value.len()
                                                                                                                                                       >=
                                                                                                                                                       1u
                                                                                                                                                   {
                                                                                                                                                    Matched(repeat_pos,
                                                                                                                                                            repeat_value)
                                                                                                                                                } else {
                                                                                                                                                    Failed
                                                                                                                                                }
                                                                                                                                            };
                                                                                                                                        match seq_res
                                                                                                                                            {
                                                                                                                                            Matched(pos,
                                                                                                                                                    names)
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                                {
                                                                                                                                                    let seq_res =
                                                                                                                                                        slice_eq(input,
                                                                                                                                                                 state,
                                                                                                                                                                 pos,
                                                                                                                                                                 "}");
                                                                                                                                                    match seq_res
                                                                                                                                                        {
                                                                                                                                                        Matched(pos,
                                                                                                                                                                _)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            {
                                                                                                                                                                let seq_res =
                                                                                                                                                                    parse___(input,
                                                                                                                                                                             state,
                                                                                                                                                                             pos);
                                                                                                                                                                match seq_res
                                                                                                                                                                    {
                                                                                                                                                                    Matched(pos,
                                                                                                                                                                            _)
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        {
                                                                                                                                                                            let match_str =
                                                                                                                                                                                input.slice(start_pos,
                                                                                                                                                                                            pos);
                                                                                                                                                                            Matched(pos,
                                                                                                                                                                                    {
                                                                                                                                                                                        RustUseList(p.clone(),
                                                                                                                                                                                                    names)
                                                                                                                                                                                    })
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                    Failed
                                                                                                                                                                    =>
                                                                                                                                                                    Failed,
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        Failed,
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            Failed
                                                                                                                                            =>
                                                                                                                                            Failed,
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                Failed,
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed
                                                                                                                    =>
                                                                                                                    Failed,
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                };
                                                                            match choice_res
                                                                                {
                                                                                Matched(pos,
                                                                                        value)
                                                                                =>
                                                                                Matched(pos,
                                                                                        value),
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let match_str =
                                                                                                        input.slice(start_pos,
                                                                                                                    pos);
                                                                                                    Matched(pos,
                                                                                                            {
                                                                                                                RustUseSimple(p.clone())
                                                                                                            })
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        v) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            slice_eq(input,
                                                                                     state,
                                                                                     pos,
                                                                                     ";");
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    input.slice(start_pos,
                                                                                                                pos);
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            v
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rust_path(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let pos =
                            if repeat_value.len() > 0 {
                                let sep_res =
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, "::");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse___(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match sep_res {
                                    Matched(newpos, _) => { newpos }
                                    Failed => break ,
                                }
                            } else { pos };
                        let step_res = parse_identifier(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1u {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rust_type(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let choice_res =
            {
                let seq_res = slice_eq(input, state, pos, "()");
                match seq_res {
                    Matched(pos, _) => { parse___(input, state, pos) }
                    Failed => Failed,
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let seq_res = slice_eq(input, state, pos, "[");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_rust_type(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "]");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        parse___(input, state,
                                                                 pos)
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, "&");
                                match seq_res {
                                    Matched(pos, _) => {
                                        parse_rust_type(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let seq_res =
                                            parse_identifier(input, state,
                                                             pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        slice_eq(input, state,
                                                                 pos, "<");
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let seq_res =
                                                                    parse_rust_type(input,
                                                                                    state,
                                                                                    pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let seq_res =
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         ">");
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        _)
                                                                                =>
                                                                                {
                                                                                    parse___(input,
                                                                                             state,
                                                                                             pos)
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            {
                                                let seq_res =
                                                    parse_identifier(input,
                                                                     state,
                                                                     pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "::");
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    parse_rust_type(input,
                                                                                    state,
                                                                                    pos)
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "(");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        {
                                                                            let mut repeat_pos =
                                                                                pos;
                                                                            let mut repeat_value =
                                                                                vec!();
                                                                            loop 
                                                                                 {
                                                                                let pos =
                                                                                    repeat_pos;
                                                                                let pos =
                                                                                    if repeat_value.len()
                                                                                           >
                                                                                           0
                                                                                       {
                                                                                        let sep_res =
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse___(input,
                                                                                                             state,
                                                                                                             pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                slice_eq(input,
                                                                                                                         state,
                                                                                                                         pos,
                                                                                                                         ",");
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        _)
                                                                                                                =>
                                                                                                                {
                                                                                                                    parse___(input,
                                                                                                                             state,
                                                                                                                             pos)
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            };
                                                                                        match sep_res
                                                                                            {
                                                                                            Matched(newpos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                newpos
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            break
                                                                                                ,
                                                                                        }
                                                                                    } else {
                                                                                        pos
                                                                                    };
                                                                                let step_res =
                                                                                    parse_rust_type(input,
                                                                                                    state,
                                                                                                    pos);
                                                                                match step_res
                                                                                    {
                                                                                    Matched(newpos,
                                                                                            value)
                                                                                    =>
                                                                                    {
                                                                                        repeat_pos
                                                                                            =
                                                                                            newpos;
                                                                                        repeat_value.push(value);
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    {
                                                                                        break
                                                                                            ;
                                                                                    }
                                                                                }
                                                                            }
                                                                            if repeat_value.len()
                                                                                   >=
                                                                                   1u
                                                                               {
                                                                                Matched(repeat_pos,
                                                                                        ())
                                                                            } else {
                                                                                Failed
                                                                            }
                                                                        };
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             ")");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos)
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let seq_res =
                                                            parse_identifier(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "")
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_expression(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    parse_choice(input, state, pos)
}
fn parse_choice(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_sequence(input, state, pos);
            match seq_res {
                Matched(pos, head) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse_slash(input, state,
                                                                pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_sequence(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        s) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Matched(pos,
                                                                                {
                                                                                    s
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, tail) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                if tail.len() > 0 {
                                                    let mut list = tail;
                                                    list.insert(0, head);
                                                    ChoiceExpr(list)
                                                } else { head }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_sequence(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_labeled(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                    match seq_res {
                        Matched(pos, elements) => {
                            {
                                let seq_res = parse_action(input, state, pos);
                                match seq_res {
                                    Matched(pos, code) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos,
                                                    {
                                                        ActionExpr(elements,
                                                                   code)
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_prefixed(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                    match seq_res {
                        Matched(pos, elements) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos,
                                        {
                                            if elements.len() != 1 {
                                                SequenceExpr(elements)
                                            } else {
                                                elements.into_iter().next().unwrap()
                                            }
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_labeled(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<TaggedExpr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, label) => {
                            {
                                let seq_res = parse_colon(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_prefixed(input, state,
                                                               pos);
                                            match seq_res {
                                                Matched(pos, expression) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Matched(pos,
                                                                {
                                                                    TaggedExpr{name:
                                                                                   Some(label),
                                                                               expr:
                                                                                   box() expression,}
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_prefixed(input, state, pos);
                    match seq_res {
                        Matched(pos, expr) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos,
                                        {
                                            TaggedExpr{name: None,
                                                       expr: box() expr,}
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_prefixed(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_dollar(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_suffixed(input, state, pos);
                                match seq_res {
                                    Matched(pos, expression) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { expression })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_and(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_suffixed(input, state, pos);
                                        match seq_res {
                                            Matched(pos, expression) => {
                                                {
                                                    let match_str =
                                                        input.slice(start_pos,
                                                                    pos);
                                                    Matched(pos,
                                                            {
                                                                PosAssertExpr(box() expression)
                                                            })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_not(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_suffixed(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, expression)
                                                    => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        NegAssertExpr(box() expression)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => parse_suffixed(input, state, pos),
                        }
                    }
                }
            }
        }
    }
}
fn parse_suffixed(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_primary(input, state, pos);
                    match seq_res {
                        Matched(pos, expression) => {
                            {
                                let seq_res =
                                    parse_question(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos,
                                                    {
                                                        OptionalExpr(box() expression)
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_primary(input, state, pos);
                            match seq_res {
                                Matched(pos, expression) => {
                                    {
                                        let seq_res =
                                            parse_starstar(input, state, pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        parse_primary(input,
                                                                      state,
                                                                      pos);
                                                    match seq_res {
                                                        Matched(pos, sep) => {
                                                            {
                                                                let match_str =
                                                                    input.slice(start_pos,
                                                                                pos);
                                                                Matched(pos,
                                                                        {
                                                                            Repeat(box() expression,
                                                                                   0,
                                                                                   None,
                                                                                   Some(box() sep))
                                                                        })
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_primary(input, state, pos);
                                    match seq_res {
                                        Matched(pos, expression) => {
                                            {
                                                let seq_res =
                                                    parse_plusplus(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_primary(input,
                                                                              state,
                                                                              pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        sep)
                                                                => {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Matched(pos,
                                                                                {
                                                                                    Repeat(box() expression,
                                                                                           1,
                                                                                           None,
                                                                                           Some(box() sep))
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_primary(input, state,
                                                              pos);
                                            match seq_res {
                                                Matched(pos, expression) => {
                                                    {
                                                        let seq_res =
                                                            parse_star(input,
                                                                       state,
                                                                       pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        input.slice(start_pos,
                                                                                    pos);
                                                                    Matched(pos,
                                                                            {
                                                                                Repeat(box() expression,
                                                                                       0,
                                                                                       None,
                                                                                       None)
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            {
                                                let start_pos = pos;
                                                {
                                                    let seq_res =
                                                        parse_primary(input,
                                                                      state,
                                                                      pos);
                                                    match seq_res {
                                                        Matched(pos,
                                                                expression) =>
                                                        {
                                                            {
                                                                let seq_res =
                                                                    parse_plus(input,
                                                                               state,
                                                                               pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                input.slice(start_pos,
                                                                                            pos);
                                                                            Matched(pos,
                                                                                    {
                                                                                        Repeat(box() expression,
                                                                                               1,
                                                                                               None,
                                                                                               None)
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    {
                                                        let start_pos = pos;
                                                        {
                                                            let seq_res =
                                                                parse_primary(input,
                                                                              state,
                                                                              pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        expression)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_lbrace(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_integer(input,
                                                                                                      state,
                                                                                                      pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                n)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_rbrace(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let match_str =
                                                                                                                input.slice(start_pos,
                                                                                                                            pos);
                                                                                                            Matched(pos,
                                                                                                                    {
                                                                                                                        Repeat(box() expression,
                                                                                                                               n,
                                                                                                                               Some(n),
                                                                                                                               None)
                                                                                                                    })
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    };
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            {
                                                                let start_pos =
                                                                    pos;
                                                                {
                                                                    let seq_res =
                                                                        parse_primary(input,
                                                                                      state,
                                                                                      pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                expression)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_lbrace(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse_integer(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        min)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse_comma(input,
                                                                                                                        state,
                                                                                                                        pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        match parse_integer(input,
                                                                                                                                            state,
                                                                                                                                            pos)
                                                                                                                            {
                                                                                                                            Matched(newpos,
                                                                                                                                    value)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                Matched(newpos,
                                                                                                                                        Some(value))
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                Matched(pos,
                                                                                                                                        None)
                                                                                                                            }
                                                                                                                        };
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                max)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let seq_res =
                                                                                                                                    parse_rbrace(input,
                                                                                                                                                 state,
                                                                                                                                                 pos);
                                                                                                                                match seq_res
                                                                                                                                    {
                                                                                                                                    Matched(pos,
                                                                                                                                            _)
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        {
                                                                                                                                            let match_str =
                                                                                                                                                input.slice(start_pos,
                                                                                                                                                            pos);
                                                                                                                                            Matched(pos,
                                                                                                                                                    {
                                                                                                                                                        Repeat(box() expression,
                                                                                                                                                               min,
                                                                                                                                                               max,
                                                                                                                                                               None)
                                                                                                                                                    })
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    Failed
                                                                                                                                    =>
                                                                                                                                    Failed,
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            };
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    {
                                                                        let start_pos =
                                                                            pos;
                                                                        {
                                                                            let seq_res =
                                                                                parse_primary(input,
                                                                                              state,
                                                                                              pos);
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        expression)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        let seq_res =
                                                                                            parse_lbrace(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse_comma(input,
                                                                                                                    state,
                                                                                                                    pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    match parse_integer(input,
                                                                                                                                        state,
                                                                                                                                        pos)
                                                                                                                        {
                                                                                                                        Matched(newpos,
                                                                                                                                value)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Matched(newpos,
                                                                                                                                    Some(value))
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Matched(pos,
                                                                                                                                    None)
                                                                                                                        }
                                                                                                                    };
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Matched(pos,
                                                                                                                            max)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            let seq_res =
                                                                                                                                parse_rbrace(input,
                                                                                                                                             state,
                                                                                                                                             pos);
                                                                                                                            match seq_res
                                                                                                                                {
                                                                                                                                Matched(pos,
                                                                                                                                        _)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    {
                                                                                                                                        let match_str =
                                                                                                                                            input.slice(start_pos,
                                                                                                                                                        pos);
                                                                                                                                        Matched(pos,
                                                                                                                                                {
                                                                                                                                                    Repeat(box() expression,
                                                                                                                                                           0,
                                                                                                                                                           max,
                                                                                                                                                           None)
                                                                                                                                                })
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                Failed,
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed
                                                                                                                    =>
                                                                                                                    Failed,
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    };
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    parse_primary(input,
                                                                                  state,
                                                                                  pos),
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_primary(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, name) => {
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            {
                                                let seq_res =
                                                    match parse_string(input,
                                                                       state,
                                                                       pos) {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_returntype(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    parse_equals(input,
                                                                                 state,
                                                                                 pos)
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { RuleExpr(name) })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_literal(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_class(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_dot(input, state, pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Matched(pos,
                                                                {
                                                                    AnyCharExpr
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_lparen(input, state,
                                                             pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_expression(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos,
                                                                    expression)
                                                            => {
                                                                {
                                                                    let seq_res =
                                                                        parse_rparen(input,
                                                                                     state,
                                                                                     pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    input.slice(start_pos,
                                                                                                pos);
                                                                                Matched(pos,
                                                                                        {
                                                                                            expression
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_action(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_braced(input, state, pos);
            match seq_res {
                Matched(pos, braced) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { braced })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_braced(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "{");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let choice_res =
                                                {
                                                    let seq_res =
                                                        parse_braced(input,
                                                                     state,
                                                                     pos);
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            slice_eq(input,
                                                                     state,
                                                                     pos, "")
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed =>
                                                parse_nonBraceCharacters(input,
                                                                         state,
                                                                         pos),
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "}");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_nonBraceCharacters(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res = parse_nonBraceCharacter(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1u {
            Matched(repeat_pos, ())
        } else { Failed }
    }
}
fn parse_nonBraceCharacter(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch: ch, next: next } =
            input.char_range_at(pos);
        match ch {
            '{' | '}' => state.mark_failure(pos, "[]"),
            _ => Matched(next, ()),
        }
    } else { state.mark_failure(pos, "[]") }
}
fn parse_equals(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "=");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_colon(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ":");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_semicolon(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ";");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_slash(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "/");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_and(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "&");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_not(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "!");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_dollar(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "$");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_question(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "?");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_star(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "*");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_starstar(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "**");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_plus(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "+");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_plusplus(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "++");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_lparen(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "(");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_rparen(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ")");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_dot(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ".");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_returns(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "->");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_lbrace(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "{");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_rbrace(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "}");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_comma(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ",");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_integer(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let ::std::str::CharRange {
                                                    ch: ch, next: next } =
                                                input.char_range_at(pos);
                                            match ch {
                                                '0' ...'9' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos, "[]"),
                                            }
                                        } else {
                                            state.mark_failure(pos, "[]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                if repeat_value.len() >= 1u {
                                    Matched(repeat_pos, ())
                                } else { Failed }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                from_str::<uint>(match_str).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, i) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { i })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_identifier(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let choice_res =
                                    parse_letter(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "_"),
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_letter(input,
                                                                         state,
                                                                         pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    parse_digit(input,
                                                                                state,
                                                                                pos);
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "_"),
                                                                }
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, chars) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { chars })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_literal(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, value) => {
                    {
                        let seq_res =
                            match slice_eq(input, state, pos, "i") {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, flags) => {
                                {
                                    let seq_res = parse___(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            LiteralExpr(value)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, string) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { string })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedString(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_doubleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            String::from_chars(s.as_slice())
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedCharacter(input: &str, state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let choice_res = parse_simpleDoubleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_hex4EscapeSequence(input,
                                                                     state,
                                                                     pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_hex8EscapeSequence(input,
                                                                             state,
                                                                             pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_eolEscapeSequence(input,
                                                                            state,
                                                                            pos),
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleDoubleQuotedCharacter(input: &str, state: &mut ParseState,
                                     pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\"");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedString(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\'");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_singleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\'");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            String::from_chars(s.as_slice())
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedCharacter(input: &str, state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let choice_res = parse_simpleSingleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_hex4EscapeSequence(input,
                                                                     state,
                                                                     pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_hex8EscapeSequence(input,
                                                                             state,
                                                                             pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_eolEscapeSequence(input,
                                                                            state,
                                                                            pos),
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleSingleQuotedCharacter(input: &str, state: &mut ParseState,
                                     pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\'");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_class(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "[");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match slice_eq(input, state, pos, "^") {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, inverted) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_classCharacterRange(input,
                                                                                      state,
                                                                                      pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_classCharacter(input,
                                                                                 state,
                                                                                 pos),
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, parts) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "]");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                match slice_eq(input,
                                                                               state,
                                                                               pos,
                                                                               "i")
                                                                    {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        flags)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                CharSetExpr(inverted.is_some(),
                                                                                                            parts)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_classCharacterRange(input: &str, state: &mut ParseState, pos: uint)
 -> ParseResult<CharSetCase> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, state, pos);
            match seq_res {
                Matched(pos, begin) => {
                    {
                        let seq_res = slice_eq(input, state, pos, "-");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_bracketDelimitedCharacter(input,
                                                                        state,
                                                                        pos);
                                    match seq_res {
                                        Matched(pos, end) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            CharSetCase{start:
                                                                            begin,
                                                                        end:
                                                                            end,}
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_classCharacter(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<CharSetCase> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, state, pos);
            match seq_res {
                Matched(pos, char_) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos,
                                { CharSetCase{start: char_, end: char_,} })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_bracketDelimitedCharacter(input: &str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<char> {
    {
        let choice_res =
            parse_simpleBracketDelimitedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_hex4EscapeSequence(input,
                                                                     state,
                                                                     pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_hex8EscapeSequence(input,
                                                                             state,
                                                                             pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_eolEscapeSequence(input,
                                                                            state,
                                                                            pos),
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleBracketDelimitedCharacter(input: &str, state: &mut ParseState,
                                         pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res = slice_eq(input, state, pos, "]");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_simpleEscapeSequence(input: &str, state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    {
                                        let choice_res =
                                            parse_digit(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    slice_eq(input, state,
                                                             pos, "x");
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "u");
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "U");
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    parse_eolChar(input,
                                                                                  state,
                                                                                  pos),
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = any_char(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match match_str.char_at(1)
                                                                {
                                                                'n' => '\n',
                                                                'r' => '\r',
                                                                't' => '\t',
                                                                x => x,
                                                            }
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_zeroEscapeSequence(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\0");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    parse_digit(input, state, pos);
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { 0u8 as char })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex2EscapeSequence(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\x");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        from_str_radix::<int>(match_str,
                                                                                              16)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex4EscapeSequence(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\u");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_hexDigit(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_hexDigit(input,
                                                                                           state,
                                                                                           pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                from_str_radix::<int>(match_str,
                                                                                                                      16)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex8EscapeSequence(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\U");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_hexDigit(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_hexDigit(input,
                                                                                           state,
                                                                                           pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_hexDigit(input,
                                                                                                       state,
                                                                                                       pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_hexDigit(input,
                                                                                                                   state,
                                                                                                                   pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                parse_hexDigit(input,
                                                                                                                               state,
                                                                                                                               pos);
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        _)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        let seq_res =
                                                                                                                            parse_hexDigit(input,
                                                                                                                                           state,
                                                                                                                                           pos);
                                                                                                                        match seq_res
                                                                                                                            {
                                                                                                                            Matched(pos,
                                                                                                                                    _)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                {
                                                                                                                                    let match_str =
                                                                                                                                        input.slice(start_pos,
                                                                                                                                                    pos);
                                                                                                                                    Matched(pos,
                                                                                                                                            {
                                                                                                                                                from_str_radix::<int>(match_str,
                                                                                                                                                                      16)
                                                                                                                                            })
                                                                                                                                }
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_eolEscapeSequence(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_eol(input, state, pos);
                        match seq_res {
                            Matched(pos, eol) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { '\n' })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_digit(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch: ch, next: next } =
            input.char_range_at(pos);
        match ch {
            '0' ...'9' => Matched(next, ()),
            _ => state.mark_failure(pos, "[]"),
        }
    } else { state.mark_failure(pos, "[]") }
}
fn parse_hexDigit(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch: ch, next: next } =
            input.char_range_at(pos);
        match ch {
            '0' ...'9' | 'a' ...'f' | 'A' ...'F' => Matched(next, ()),
            _ => state.mark_failure(pos, "[]"),
        }
    } else { state.mark_failure(pos, "[]") }
}
fn parse_letter(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let choice_res = parse_lowerCaseLetter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_upperCaseLetter(input, state, pos),
        }
    }
}
fn parse_lowerCaseLetter(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch: ch, next: next } =
            input.char_range_at(pos);
        match ch {
            'a' ...'z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[]"),
        }
    } else { state.mark_failure(pos, "[]") }
}
fn parse_upperCaseLetter(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch: ch, next: next } =
            input.char_range_at(pos);
        match ch {
            'A' ...'Z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[]"),
        }
    } else { state.mark_failure(pos, "[]") }
}
fn parse___(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_eol(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => parse_comment(input, state, pos),
                            }
                        }
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_comment(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let choice_res = parse_singleLineComment(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_multiLineComment(input, state, pos),
        }
    }
}
fn parse_singleLineComment(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "//");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            parse_eolChar(input, state, pos);
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        any_char(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_multiLineComment(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "/*");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let seq_res =
                                            {
                                                let assert_res =
                                                    slice_eq(input, state,
                                                             pos, "*/");
                                                match assert_res {
                                                    Failed =>
                                                    Matched(pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                any_char(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "*/")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_eol(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "\n");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "\r\n");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, "\r");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    slice_eq(input, state, pos, "\u2028");
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "\u2029"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_eolChar(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch: ch, next: next } =
            input.char_range_at(pos);
        match ch {
            '\n' | '\r' | '\u2028' | '\u2029' => Matched(next, ()),
            _ => state.mark_failure(pos, "[]"),
        }
    } else { state.mark_failure(pos, "[]") }
}
fn parse_whitespace(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch: ch, next: next } =
            input.char_range_at(pos);
        match ch {
            ' ' | '\t' | '\xa0' | '\ufeff' | '\u1680' | '\u180e' | '\u2000'
            ...'\u200a' | '\u202f' | '\u205f' | '\u3000' => Matched(next, ()),
            _ => state.mark_failure(pos, "[]"),
        }
    } else { state.mark_failure(pos, "[]") }
}
pub fn grammar(input: &str) -> Result<Grammar, String> {
    let mut state = ParseState::new();
    match parse_grammar(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    Err(format!("Error at {}: Expected {}" , pos_to_line
                ( input , state . max_err_pos ) , state . expected))
}
